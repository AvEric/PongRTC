{"ts":1354048699755,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":true,"ts":1354048710148,"patch":[[{"diffs":[[1,"/**\r\n * Library for detecting and tracking the position of a face in a canvas object\r\n *\r\n * usage:\r\n *     // create a new tracker\r\n *\t var ft = new headtrackr.facetrackr.Tracker();\r\n *\t // initialize it with a canvas\r\n *\t ft.init(some_canvas);\r\n *\t // track in canvas\r\n *\t ft.track();\r\n *\t // get position of found object\r\n *\t var currentPos = ft.getTrackObj();\r\n *\t currentPos.x // x-coordinate of center of object on canvas \r\n *\t currentPos.y // y-coordinate of center of object on canvas \r\n *\t currentPos.width // width of object\r\n *\t currentPos.height // height of object\r\n *\t currentPos.angle // angle of object in radians\r\n *\t currentPos.confidence // returns confidence (doesn't work for CS yet)\r\n *\t currentPos.detection // current detectionmethod (VJ or CS)\r\n *\t currentPos.time // time spent\r\n * \r\n * @author auduno / github.com/auduno\r\n */\r\n\r\nheadtrackr.facetrackr = {};\r\n\r\n/**\r\n * optional parameters to params:\r\n *\t smoothing : whether to use smoothing on output (default is true)\r\n *\t smoothingInterval : should be the same as detectionInterval plus time of tracking (default is 35 ms)\r\n *\t sendEvents : whether to send events (default is true)\r\n *\t whitebalancing : whether to wait for camera whitebalancing before starting detection (default is true)\r\n *   calcAnglss : whether to calculate orientation of tracked object (default for facetrackr is false)\r\n *\r\n * @constructor\r\n */\r\nheadtrackr.facetrackr.Tracker = function(params) {\r\n  \r\n  if (!params) params = {};\r\n  \r\n  if (params.sendEvents === undefined) params.sendEvents = true;\r\n  if (params.whitebalancing === undefined) params.whitebalancing = true;\r\n  if (params.debug === undefined) {\r\n    params.debug = false;\r\n  } else {\r\n    if (params.debug.tagName != 'CANVAS') params.debug = false;\r\n  }\r\n  if (params.whitebalancing) {\r\n    var _currentDetection = \"WB\";\r\n  } else {\r\n    var _currentDetection = \"VJ\";\r\n  }\r\n  if (params.calcAngles == undefined) params.calcAngles = false;\r\n  \r\n  var _inputcanvas, _curtracked, _cstracker;\r\n  \r\n  var _confidenceThreshold = -10; // needed confidence before switching to Camshift\r\n  var previousWhitebalances = []; // array of previous 10 whitebalance values\r\n  var pwbLength = 15;\r\n  \r\n  this.init = function(inputcanvas) {\r\n    _inputcanvas = inputcanvas\r\n    // initialize cs tracker\r\n    _cstracker = new headtrackr.camshift.Tracker({calcAngles : params.calcAngles});\r\n  }\r\n  \r\n  this.track = function() {\r\n    var result;\r\n    // do detection\r\n    if (_currentDetection == \"WB\") {\r\n      result = checkWhitebalance();\r\n    } else if (_currentDetection == \"VJ\") {\r\n      result = doVJDetection();\r\n    } else if (_currentDetection == \"CS\") {\r\n      result = doCSDetection();\r\n    }\r\n    \r\n    // check whether whitebalance is stable before starting detection\r\n    if (result.detection == \"WB\") {\r\n      if (previousWhitebalances.length >= pwbLength) previousWhitebalances.pop();\r\n      previousWhitebalances.unshift(result.wb);\r\n      if (previousWhitebalances.length == pwbLength) {\r\n        //get max\r\n        var max = Math.max.apply(null, previousWhitebalances);\r\n        //get min\r\n        var min = Math.min.apply(null, previousWhitebalances);\r\n        \r\n        // if difference between the last ten whitebalances is less than 2,\r\n        //   we assume whitebalance is stable\r\n        if ((max-min) < 2) {\r\n          // switch to facedetection\r\n          _currentDetection = \"VJ\";\r\n        }\r\n      }\r\n    }\r\n    // check if Viola-Jones has found a viable face\r\n    if (result.detection == \"VJ\" && result.confidence > _confidenceThreshold) {\r\n      // switch to Camshift\r\n      _currentDetection = \"CS\";\r\n      // when switching, we initalize camshift with current found face\r\n      var cRectangle = new headtrackr.camshift.Rectangle(\r\n        Math.floor(result.x), \r\n        Math.floor(result.y), \r\n        Math.floor(result.width), \r\n        Math.floor(result.height)\r\n      );\r\n      _cstracker.initTracker(_inputcanvas, cRectangle);\r\n    }\r\n    \r\n    _curtracked = result;\r\n    \r\n    if (result.detection == \"CS\" && params.sendEvents) {\r\n      // send events\r\n      var evt = document.createEvent(\"Event\");\r\n      evt.initEvent(\"facetrackingEvent\", true, true);\r\n      evt.height = result.height;\r\n      evt.width = result.width;\r\n      evt.angle = result.angle;\r\n      evt.x = result.x;\r\n      evt.y = result.y;\r\n      evt.confidence = result.confidence;\r\n      evt.detection = result.detection;\r\n      evt.time = result.time;\r\n      document.dispatchEvent(evt);\r\n    }\r\n  }\r\n  \r\n  this.getTrackingObject = function() {\r\n    return _curtracked.clone();\r\n  }\r\n  \r\n  // Viola-Jones detection\r\n  function doVJDetection() {\r\n    // start timing\r\n    var start = (new Date).getTime();\r\n    \r\n    // we seem to have to copy canvas to avoid interference with camshift\r\n    // not entirely sure why\r\n    // TODO: ways to avoid having to copy canvas every time\r\n    var ccvCanvas = document.createElement('canvas');\r\n    ccvCanvas.width = _inputcanvas.width;\r\n    ccvCanvas.height = _inputcanvas.height;\r\n    ccvCanvas.getContext(\"2d\").drawImage(\r\n      _inputcanvas, 0, 0, ccvCanvas.width, ccvCanvas.height\r\n    );\r\n    \r\n    var comp = headtrackr.ccv.detect_objects(\r\n        headtrackr.ccv.grayscale(ccvCanvas), headtrackr.cascade, 5, 1\r\n    );\r\n    \r\n    // end timing\r\n    var diff = (new Date).getTime() - start;\r\n    \r\n    // loop through found faces and pick the most likely one\r\n    // TODO: check amount of neighbors and size as well?\r\n    // TODO: choose the face that is most in the center of canvas?\r\n    var candidate;\r\n    if (comp.length > 0) {\r\n      candidate = comp[0];\r\n    }\r\n    for (var i = 1; i < comp.length; i++) {\r\n      if (comp[i].confidence > candidate.confidence) {\r\n        candidate = comp[i];\r\n      }\r\n    }\r\n    \r\n    // copy information from ccv object to a new trackObj\r\n    var result = new headtrackr.facetrackr.TrackObj();\r\n    if (!(candidate === undefined)) {\r\n      result.width = candidate.width;\r\n      result.height = candidate.height;\r\n      result.x = candidate.x;\r\n      result.y = candidate.y;\r\n      result.confidence = candidate.confidence;\r\n    }\r\n    \r\n    // copy timing to object\r\n    result.time = diff;\r\n    result.detection = \"VJ\";\r\n    \r\n    return result;\r\n  }\r\n  \r\n  // Camshift detection\r\n  function doCSDetection() {\r\n    \r\n    // start timing\r\n    var start = (new Date).getTime();\r\n    // detect\r\n    _cstracker.track(_inputcanvas);\r\n    var csresult = _cstracker.getTrackObj();\r\n    \r\n    // if debugging, draw backprojection image on debuggingcanvas\r\n    if (params.debug) {\r\n      params.debug.getContext('2d').putImageData(_cstracker.getBackProjectionImg(),0,0);\r\n    }\r\n    \r\n    // end timing\r\n    var diff = (new Date).getTime() - start;\r\n    \r\n    // copy information from CS object to a new trackObj\r\n    var result = new headtrackr.facetrackr.TrackObj();\r\n    result.width = csresult.width;\r\n    result.height = csresult.height;\r\n    result.x = csresult.x;\r\n    result.y = csresult.y;\r\n    // TODO: should we adjust this angle to be \"clockwise\"?\r\n    result.angle = csresult.angle;\r\n    // TODO: camshift should pass along some sort of confidence?\r\n    result.confidence = 1;\r\n    \r\n    // copy timing to object\r\n    result.time = diff;\r\n    result.detection = \"CS\";\r\n    \r\n    return result;\r\n  }\r\n  \r\n  // Whitebalancing\r\n  function checkWhitebalance() {\r\n    var result = new headtrackr.facetrackr.TrackObj();\r\n    // get whitebalance value\r\n    result.wb = headtrackr.getWhitebalance(_inputcanvas);\r\n    result.detection = \"WB\";\r\n\r\n    return result\r\n  }\r\n};\r\n\r\n/**\r\n * @constructor\r\n */\r\nheadtrackr.facetrackr.TrackObj = function() {\r\n  this.height = 0;\r\n  this.width = 0;\r\n  this.angle = 0;\r\n  this.x = 0;\r\n  this.y = 0;\r\n  this.confidence = -10000;\r\n  this.detection = '';\r\n  this.time = 0;\r\n  \r\n  this.clone = function() {\r\n    var c = new headtrackr.facetrackr.TrackObj();\r\n    c.height = this.height;\r\n    c.width = this.width;\r\n    c.angle = this.angle;\r\n    c.x = this.x;\r\n    c.y = this.y;\r\n    c.confidence = this.confidence;\r\n    c.detection = this.detection;\r\n    c.time = this.time;\r\n    return c;\r\n  }\r\n};"]],"start1":0,"start2":0,"length1":0,"length2":8126}]],"length":8126,"saved":false}
