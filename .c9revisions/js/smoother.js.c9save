{"ts":1354048647337,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":true,"ts":1354048663167,"patch":[[{"diffs":[[1,"/**\r\n * Smoother for smoothing tracked positions of face\r\n *\r\n * Double Exponential Smoothing-based Prediction\r\n *     see: http://www.cs.brown.edu/people/jjl/pubs/kfvsexp_final_laviola.pdf\r\n *\t \"Double Exponential Smoothing: An alternative to Kalman Filter-based Predictive Tracking\"\r\n *\r\n * @author auduno / github.com/auduno\r\n * @param {number} a Smoothing parameter, between 0 and 1. 0 is max smoothing, 1 no smoothing.\r\n * @param {number} interval The ms interval between tracking events\r\n * @constructor\r\n */\r\nheadtrackr.Smoother = function(alpha, interval) {\r\n\t\r\n\t// alpha = 0.35 smoothes ok while not introducing too much lag\r\n\t\r\n\tvar sp, sp2, sl, newPositions, positions;\r\n\tvar updateTime = new Date();\r\n\t\r\n\tthis.initialized = false;\r\n\t\r\n\t// whether to use linear interpolation for times in intervals\r\n\tthis.interpolate = false;\r\n\t\r\n\tthis.init = function(initPos) {\r\n\t\tthis.initialized = true;\r\n\t\tsp = [initPos.x, initPos.y, initPos.z, initPos.width, initPos.height];\r\n\t\tsp2 = sp;\r\n\t\tsl = sp.length;\r\n\t}\r\n\t\r\n\tthis.smooth = function(pos) {\r\n\t\t\r\n\t\tpositions = [pos.x, pos.y, pos.z, pos.width, pos.height];\r\n\t\t\r\n\t\tif (this.initialized) {\r\n\t\t\t// update\r\n\t\t\tfor (var i = 0;i < sl;i++) {\r\n\t\t\t\tsp[i] = alpha*positions[i]+(1-alpha)*sp[i];\r\n\t\t\t\tsp2[i] = alpha*sp[i]+(1-alpha)*sp2[i];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// set time\r\n\t\t\tupdateTime = new Date();\r\n\t\t\t\r\n\t\t\tvar msDiff = (new Date())-updateTime;\r\n\t\t\tvar newPositions = predict(msDiff);\r\n\t\t\t\r\n\t\t\tpos.x = newPositions[0];\r\n\t\t\tpos.y = newPositions[1];\r\n\t\t\tpos.z = newPositions[2];\r\n\t\t\tpos.width = newPositions[3];\r\n\t\t\tpos.height = newPositions[4];\r\n\t\t\t\r\n\t\t\treturn pos;\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction predict(time) {\r\n\t\t\r\n\t\tvar retPos = [];\r\n\t\t\r\n\t\tif (this.interpolate) {\r\n\t\t\tvar step = time/interval;\r\n\t\t\tvar stepLo = step >> 0;\r\n\t\t\tvar ratio = alpha/(1-alpha);\r\n\t\t\t\r\n\t\t\tvar a = (step-stepLo)*ratio;\r\n\t\t\tvar b = (2 + stepLo*ratio);\r\n\t\t\tvar c = (1 + stepLo*ratio);\r\n\t\t\t\r\n\t\t\tfor (var i = 0;i < sl;i++) {\r\n\t\t\t\tretPos[i] = a*(sp[i]-sp2[i]) + b*sp[i] - c*sp2[i];\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar step = time/interval >> 0;\r\n\t\t\tvar ratio = (alpha*step)/(1-alpha);\r\n\t\t\tvar a = 2 + ratio;\r\n\t\t\tvar b = 1 + ratio;\r\n\t\t\tfor (var i = 0;i < sl;i++) {\r\n\t\t\t\tretPos[i] = a*sp[i] - b*sp2[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn retPos;\r\n\t}\r\n}"]],"start1":0,"start2":0,"length1":0,"length2":2266}]],"length":2266,"saved":false}
